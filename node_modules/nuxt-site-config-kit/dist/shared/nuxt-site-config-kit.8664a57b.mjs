import { tryUseNuxt, installModule, resolvePath } from '@nuxt/kit';
import { readPackageJSON } from 'pkg-types';
import { createSiteConfigStack, envSiteConfig } from 'site-config-stack';
import { withoutProtocol } from 'ufo';
import { env, isDevelopment } from 'std-env';

async function initSiteConfig(nuxt = tryUseNuxt()) {
  if (!nuxt)
    return;
  let siteConfig = nuxt._siteConfig;
  if (siteConfig)
    return siteConfig;
  siteConfig = createSiteConfigStack();
  const rootDir = nuxt?.options.rootDir || process.cwd?.() || false;
  siteConfig.push({
    _context: "system",
    _priority: -15,
    name: rootDir ? rootDir.split("/").pop() : void 0,
    env: process.env.NODE_ENV
  });
  if (rootDir) {
    const pkgJson = await readPackageJSON(void 0, { startingFrom: rootDir });
    if (pkgJson) {
      siteConfig.push({
        _context: "package.json",
        _priority: -10,
        name: pkgJson.name,
        description: pkgJson.description
      });
    }
  }
  siteConfig.push({
    _context: "vendorEnv",
    _priority: -5,
    url: [
      // vercel
      process.env.VERCEL_URL,
      process.env.NUXT_ENV_VERCEL_URL,
      // netlify
      process.env.URL,
      // cloudflare pages
      process.env.CF_PAGES_URL
    ].find((k) => Boolean(k)),
    name: [
      // vercel
      process.env.NUXT_ENV_VERCEL_GIT_REPO_SLUG,
      // netlify
      process.env.SITE_NAME
    ].find((k) => Boolean(k))
  });
  const runtimeConfig = nuxt.options.runtimeConfig;
  const runtimeConfigEnvKeys = [
    ...Object.entries(runtimeConfig.site || {}).filter(([k]) => k.startsWith("site")).map(([k, v]) => [k.replace(/^site/, ""), v]),
    ...Object.entries([...Object.entries(runtimeConfig), ...Object.entries(runtimeConfig.public)]).filter(([k]) => k.startsWith("site")).map(([k, v]) => [k.replace(/^site/, ""), v])
  ];
  siteConfig.push({
    _priority: -2,
    _context: "legacyRuntimeConfig",
    ...Object.fromEntries(runtimeConfigEnvKeys)
  });
  siteConfig.push({
    _context: "buildEnv",
    _priority: -1,
    ...envSiteConfig(process.env)
  });
  nuxt._siteConfig = siteConfig;
  return siteConfig;
}
async function installNuxtSiteConfig(nuxt = tryUseNuxt()) {
  await installModule(await resolvePath("nuxt-site-config"));
  await initSiteConfig(nuxt);
}
function getSiteConfigStack(nuxt = tryUseNuxt()) {
  if (!nuxt)
    throw new Error("Nuxt context is missing.");
  if (!nuxt._siteConfig)
    throw new Error("Site config is not initialized. Make sure you are running your module after nuxt-site-config.");
  return nuxt._siteConfig;
}
function updateSiteConfig(input, nuxt = tryUseNuxt()) {
  const container = getSiteConfigStack(nuxt);
  container.push(input);
}
function useSiteConfig(nuxt = tryUseNuxt()) {
  const container = getSiteConfigStack(nuxt);
  return container.get();
}

function useNitroOrigin() {
  const cert = env.NITRO_SSL_CERT;
  const key = env.NITRO_SSL_KEY;
  let host = env.NITRO_HOST || env.HOST || false;
  let port = env.NITRO_PORT || env.PORT || (isDevelopment ? 3e3 : false);
  let protocol = cert && key || !isDevelopment ? "https" : "http";
  if ((isDevelopment || env.prerender) && env.NUXT_VITE_NODE_OPTIONS) {
    const origin = JSON.parse(env.NUXT_VITE_NODE_OPTIONS).baseURL.replace("/__nuxt_vite_node__", "");
    host = withoutProtocol(origin);
    protocol = origin.includes("https") ? "https" : "http";
  }
  if (typeof host === "string" && host.includes(":")) {
    port = host.split(":").pop();
    host = host.split(":")[0];
  }
  port = port ? `:${port}` : "";
  return `${protocol}://${host}${port}/`;
}

export { installNuxtSiteConfig as a, updateSiteConfig as b, useNitroOrigin as c, getSiteConfigStack as g, initSiteConfig as i, useSiteConfig as u };
